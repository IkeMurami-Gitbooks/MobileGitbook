# iOS

## Что ищем

* AppLinks и Universal Links: какие в приложении объявлены, как используются, какие параметры принимают.
* Работа с WebView компонентом. Смотрим, что все правильно настроено (рекомендации в MSTG и на просторе интернета). Здесь могут быть вулны, специфичные для веб-приложений.
* Хранение информации в Keychain и в хранилище приложения (в MSTG можно почитать о тех местах, где приложение может хранить информацию)
* Работа с AppExtensions (если применимо)
* TLS: устанавливается защищенное соединение, SSLPinning, сам трафик не трогаем (если что бросится в глаза — ок, но API не в рамках скопа этих работ).
* Шифрование: все по рекомендациям используется, все параметры проверяются (где это применимо)
* Захардкоженные секреты
* Никакие критичные действия не выполняются в обход локальной аутентификации (даже гипотетические)
* Заказчик указал, что у проекта появились новые зависимости (см jira). Если увидите их где, посмотрите, что библиотеки используются безопасно для самого проекта (если применимо)

## Mobile / iOS: Базовые проверки

Инструменты: objection, frida, frida-tools, ida/ghidra, ..

* Зафиксировать версию приложения, тестирование которого происходит
* Backups: сделать заметки (скрины, если необходимо) по тому, что и где хранится. Если приложение хранит перс данные, указать в каком виде и какой набор этих данных
* Забрать IPA-образ приложения с устройства и загрузить в MobSF. Если mobsf что покажет — зафиксировать
* Наличие встроенного механизма SSL Pinning для всех запросов приложения. Если есть — написать frida-хуки обхода, чтобы весь трафик приложения мы могли видеть в Burp Suite. Если обход не получается, написать хуки для логирования запросов в консоль.
* Objection: с какими флагами собраны бинари — скрин
* Проверить логи (на маке приложение `Console.app`). Если видим запросы, какие-то данные о клиенте и/или работе приложения (ошибки и тп) — оформляем как Information Disclosure
* Собираем строки из IPA-образа (IDA или ipanema, например). Ищем артифакты сборки и информацию о тестовых стендах, настройках тестовых сред и тп
* AppLinks и Universal Links: какие в приложении объявлены, как используются, какие параметры принимают. Примеры линков
* Backups: через objection узнаем, какие записи есть в iOS Keychain. Какие данные там хранятся, с какими флагами (могут ли эти записи попасть в бэкап приложения)
* Firebase: использует ли приложение firebase-хранилище. Есть ли права на чтение.

## MSTG

### Sensitive Functionality Exposure through IPC

Конфиденциальная информация летать тут без защиты направо и налево не должна

* Custom URL Schemes
* Universal Links
* UIActivity Sharing
* App Extensions
* UIPasteboard

#### AppLinks / DeepLinks

* Checking the Associated Domains entitlement (ищем `applinks:`)
* Retrieving the Apple App Site Association file

Проверяем домены на `domain.com/.well-known/apple-app-site-association` или `domain.com/apple-app-site-association`

* Checking the link receiver method

Ищем:

```
application:continueUserActivity:restorationHandler:
```

* Checking the data handler method

Должный проверить, как данные обрабатываются в предыдущем методе.

* Checking if the app is calling other app's universal links

Ищем вызовы

```
openURL:options:completionHandler:
```

Этот метод может использоваться и для Custom URL Schemes.

**Static test for custom URL schemes**

* Testing custom URL schemes registration
* Testing application query schemes registration
* Testing URL handling and validation
* Testing URL requests to other apps
* Testing for deprecated methods

Кратко, ищем openUrl (без учета регистра)

#### UIActivity Sharing

**Sent data**

When testing UIActivity Sharing you should pay special attention to:

* the data (items) being shared,
* the custom activities,
* the excluded activity types.

If having the source code, you should take a look at the UIActivityViewController:

* Inspect the activities passed to the init(activityItems:applicationActivities:) method.
* Check if it defines custom activities (also being passed to the previous method).
* Verify the excludedActivityTypes, if any.

**Received data**

Проверяем

* определены ли в приложении custom document types (by looking into Exported/Imported UTIs -> Xcode project / Info). The list of all system declared UTIs (Uniform Type Identifiers) can be found in the archived Apple Developer Documentation (https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple\_ref/doc/uid/TP40009259).
* Если в приложении определены любые document type, приложение может открывать файлы этого типа.
* if the app properly verifies the received data by looking into the implementation of `application:openURL:options:` (or its deprecated version `UIApplicationDelegate application:openURL:sourceApplication:annotation:`) in the app delegate.

Если нет исх кода, лезем в Info.plist:

* `UTExportedTypeDeclarations/UTImportedTypeDeclarations` if the app declares exported/imported custom document types.
* `CFBundleDocumentTypes` to see if the app specifies any document types that it can open.

#### App Extensions

App Extension – исполняемые файлы, которые запускаются независимо от содержащего их приложения (Containing App).

App Extension не могут быть опубликованы в App Store, только вместе с Containing App.

Host App — приложение, которое пользователь использует для запуска App Extension.

Подробнее: https://habr.com/en/company/mobileup/blog/441890/

The static analysis will take care of:

* Verifying if the app contains app extensions

Ищем `NSExtensionPointIdentifier`.

* Determining the supported data types

Ищем в app extension's Info.plist `NSExtensionActivationRule`. Будут поддерживаться только эти данные (и для которых MaxCount не 0)

* Checking data sharing with the containing app

Данные передаются через App Groups или через NSUserDefaults (тоже через app group). Еще важное замечание: App должна настроить Shared Container, если App extension использует NSURLSession. Следовательно, Extension и Containing App будут иметь доступ к передаваемым данным.

* Verifying if the app restricts the use of app extensions

Host app может настроить ограничение на использование app extension для своих данных. Делается это через следующий метод — `application:shouldAllowExtensionPointIdentifier:`.

Актуально это для кастомных клавиатур, например.

#### UIPasteboard

Используется для обмена данными между приложениями.

* systemwide general pasteboard: для обмена данными с любыми приложениями (персистятся даже при перезапуске устройства или при переустановке приложения)
* custom / named pasteboards: для обмена даными между приложениями с одним team ID. Данные не персистятся по умолчанию.

Некоторые соображения безопасности:

* Пользователи не могут предоставлять и отклонять приложениям в разрешении на чтение буфера обмена
* Приложения в фоне не могут читать буфер обмена
* Apple не рекомендует использовать named pasteboards: следует использовать shared containers.
* Начиная с iOS 10 появилась новая фича Universal Clipboard (включена по умолчанию), которая позволяет создавать буфер обмена между устройствами для одного и того же приложения. Эта фича может отключена, а так же можно установить время жизни скопированной информации.

Статический анализ

1. systemwide general pasteboard

Ищем generalPasteboard. Этот ти буфера обмена не должен использоваться для чувствительных данных.

1. custom pasteboards

Инициализируются методами `pasteboardWithName:create:` или `pasteboardWithUniqueName`. Если буфер обмена настроен как персистент (ищем вызов `setPersistent:`), подсвечиваем, что надо использовать shared container.

В дополнение:

* Проверить, что удаляется буфер обмена `removePasteboardWithName:`, что делает его не действительным, освобождая все используемые им ресурсы (не влияет на general pasteboard)
* Проверить, if there are excluded pasteboards, there should be a call to `setItems:options:` with the `UIPasteboardOptionLocalOnly` option.
* Проверить, if there are expiring pasteboards, there should be a call to `setItems:options:` with the `UIPasteboardOptionExpirationDate` option.
* Проверить, что приложение очищает буфер обмена, если оно уходит в фоновый режим или при завершении работы. Это может делаться для ограничения раскрытия конфиденциальной информации (например, парольными менеджерами).

### WebView

https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06h-testing-platform-interaction#testing-ios-webviews-mstg-platform-5

Ищем:

* UIWebView (deprecated)
* WKWebView
* SFSafariViewController

For the static analysis we will focus mostly on the following points having UIWebView and WKWebView under scope.

* Identifying WebView usage
* Testing JavaScript configuration
* Testing for mixed content
* Testing for WebView URI manipulation

Other:

* Testing how WebViews are loaded
* Testing WebView file access (`file://`)
* Checking telephone number detection

Также ищем все упоминания о "JavaScript" (в любом регистре)

#### Native Bridge

Как и в android есть возможность общаться между Native App и WebView.

UIWebView — JSContext, JSExport protocol. Все объекты, обернутые в JSExport, доступны в JS коде.

WKWebView – JS может отправить данные в Native App через механизм postMessage. JS объекты подкапотом сконвертируются в ObjC или Swift объекты. Обработчики регистрируются с помощью метода `add(_ scriptMessageHandler:name:)`

### Хранение информации

### TLS, Pinning, Network

### Crypto / Secrets

### Obj-C с чистым `C/C++`-кодом
